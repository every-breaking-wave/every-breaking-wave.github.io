---
title: 简单排序算法
catalog: true
date: 2022-09-17 00:22:57
lang: cn
header-img: /img/scenery/default.jpg
tags: 算法学习
categories: 算法
---

### 排序

稳定的排序指相同大小的数排完之后顺序不变

- 快排不稳定
- 归并排序稳定

#### 1. 快排 (平均时间复杂度：O(nlogn) ）

- 确定分界点 ： q[l], q[l + r /2 ], q[r] 均可， 对于有一定顺序的选择 l + r / 2
- 调整区间： 使左边所有数均小于x，右边所有数大于x （**key step**)
- 递归处理左右两端

调整方式：**双指针法**

- 左右两个指针指向数组首位
- 对于左指针，若所指数字 ≤ x，指针右移，对于右指针操作相反
- 直到两指针无法移动，**交换两个指针对应位置的数**
- 之后两指针继续按照上述方式向中间移动

易错点：快排时选取的边界不当可能导致死循环

```C
void quick_sort(int q[], int l, int r) {
    if (l >= r) return;
    int x = q[(l + r + 1) >> 1];   // 这里是 l + r 还是 l + r + 1 取决于后面递归的时候用的是i 还是 j
    int i = l - 1;
    int j = r + 1;
    while (i < j) {
        do i ++ ; while (q[i] < x);   // 先执行一遍
        do j -- ; while (q[j] > x);
        if (i < j) 
            swap(q[i], q[j]);
    }
    // 以上循环结束后，i >= j
    
    // int i = l, j = r;
    // while(i < j) {
    //     while(q[i] < x) i++;
    //     while(q[j] > x) j--;
    //     if(i < j)
    //         swap(q[i], q[j]);
    // }
    // 注释写法会出现死循环，因为可能会出现两侧指针指向的值都等于x的
    // 为了是下行的 i - 1 != r, i应该至少移动两次
    quick_sort(q, l, i - 1);   // 取决于这里
    quick_sort(q, i, r);
}
```

#### 2. 归并排序 (用于合并两个有序数列，时间复杂度：O(nlogn))

1. 确定分界点 mid = (l + r ) /2
2. 递归排序left， right
3. 归并，两边合二为一 （key step)
   - 注意处理剩余的部分

```C
void merge_sort(int q[], int l, int r){
    if(l >= r) return;
    int mid = (l + r) >> 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);
    int i = l, j = mid + 1, k = 0;
    while (i <= mid && j <= r) {
        if(q[i] <= q[j]) {
            tmp[k++] = q[i++];
        } else {
            tmp[k++] = q[j++];
        }
    }
    while (i <= mid ) tmp[k++] = q[i++];
    while (j <= r) tmp[k++] = q[j++];
    for (i = l, j = 0; i <= r; ++i, ++j) {
        q[i] = tmp[j];
    }
}
```
