---
layout: post/cn
title: 前缀和与差分
catalog: true
date: 2022-09-18 15:20:23
header-img: /img/header_img/lml_bg.jpg
tags: 算法学习
categories: 算法

---

## 前缀和问题

前缀和主要是用于需要频繁地对数列中某块连续区间求和，相比于每次时间复杂度为 O(n) 的累加，我们只需要在事先计算好的前缀和数列中取出对应位置的数作差即可，是一种用**空间换时间**的策略。

- 一维前缀和

$$
S[i]=a[1]+a[2]+...a[i] \\\\ a[l]+...+a[r]=S[r]−S[l−1]
$$



- 二维前缀和

$$
S[i, j] = 第i行j列格子左上部分所有元素的和 \\\\
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：\\\\ 
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
$$

## 一维差分问题

![](https://wave-pics.oss-cn-shanghai.aliyuncs.com/pics/%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0.png)

```C++
//差分 时间复杂度 o(m)
#include<iostream>
using namespace std;
const int N = 1e5 + 10;
int a[N], b[N];
int main(){
    int n, m;
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++){
        scanf("%d", &a[i]);
        b[i] = a[i] - a[i - 1];      //构建差分数组
    }
    int l, r, c;
    while (m--){
        scanf("%d%d%d", &l, &r, &c);
        b[l] += c;     //将序列中[l, r]之间的每个数都加上c
        b[r + 1] -= c;
    }
    for (int i = 1; i <= n; i++){
        a[i] = b[i] + a[i - 1];    //前缀和运算
        printf("%d ", a[i]);
    }
    return 0;
}
```

可以看到我们构造了差分数组 b，且有
$$
b[n]=a[n]−a[n−1]
$$
**对于b[n] 的更改会影响a[n] 从n开始的每一个值**， 因此我们对a进行批量修改时，只需要更改b中对应的位置即可。



## 二维差分问题

我们将问题拓展到二维来看：

```C++
#include<iostream>
#include<cstdio>
using namespace std;
const int N = 1e3 + 10;
int a[N][N], b[N][N];
void insert(int x1, int y1, int x2, int y2, int c){
    b[x1][y1] += c;
    b[x2 + 1][y1] -= c;
    b[x1][y2 + 1] -= c;
    b[x2 + 1][y2 + 1] += c;
}
int main(){
    int n, m, q;
    cin >> n >> m >> q;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            cin >> a[i][j];
    for (int i = 1; i <= n; i++){
        for (int j = 1; j <= m; j++){
            insert(i, j, i, j, a[i][j]);      //构建差分数组
        }
    }
    while (q--){
        int x1, y1, x2, y2, c;
        cin >> x1 >> y1 >> x2 >> y2 >> c;
        insert(x1, y1, x2, y2, c);
    }
    for (int i = 1; i <= n; i++){
        for (int j = 1; j <= m; j++){
            b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1]; 
            //二维前缀和，直接在b上处理，因为 a[1][1] == b[1][1]
        }
    }
    for (int i = 1; i <= n; i++){
        for (int j = 1; j <= m; j++){
            cout << b[i][j] << ' ';
        }
        cout << endl;
    }
    return 0;
}
```

与一维问题中不同的处理时，在初始化差分数组 b 时，我们采用了和更新 b 一样的接口 **insert**， 可以理解为 a 是在一个初始全为0的数组上逐个插入的，而 b 也随着 a 的插入更新。

### 局限性

差分算法看上去很方便但有不小的局限，每次对前缀和数组（a）的批量更改变成了对 差分数组（b）的常数次更改，的确减少了计算次数，但缺点在于改变的结果无法马上反应到前缀和数组上，若想得到前缀和数组中的具体的值，仍然需要借助差分数组遍历更新（在一维中这个代价是O(n)) ，可见这种算法有以下使用情景：

- 对于数组有多次的，连续区间上的统一更改

不适合：

- 对数组进行少量的，非连续或不统一的更改

